from skynet.utils.utils import *
from skynet.errors import *
from chem.basisset import *
from chem.data import *
from chem.quantum import *
import sys
import re
import os
import os.path

MAX_BASIS = 7
sys.setrecursionlimit(100)

LATEX_FORMAT =  Formatter(float='$%6.2f$', plus=True)
DEFAULT_FORMAT =  Formatter(float='%12.8f', plus=True)
METHODS = [
    'scf',
    'mp2',
    'ccsd',
    'ccsd(t)',
    'ccsdt',
    'ccsdt(q)',
]

class EnergyGroup(DataSet):
    import math
    
    def __init__(self, dataSet=[], basisTemplate=None, type="default"):
        DataSet.__init__(self, dataSet)
        self.type = type
        self.basisTemplate = basisTemplate
        if not self.basisTemplate:
            if dataSet: #make sure we actually have data points
                template = dataSet[0].getAttribute('basis')
                if not template:
                    print "No basis attribute"
                    print dataSet
                    sys.exit()
                self.basisTemplate = Basis(template)
            else:   
                basisTemplate = Basis("cc-pvdz") #something generic

    def __getitem__(self, key):
        #first try basis, wavefunction
        check = self.getDataPoint(wavefunction=self.type, basis=key)
        if check:
            return check

        #next try just wavefunction
        check = self.getDataPoint(wavefunction=key)
        if check:
            return check

        raise KeyError

    def getBasisTemplate(self):
        return self.basisTemplate


class ExtrapolationObject(Identity):

    numberToExtrapolate = 0
    defaultPreceeding = None

    def __init__(self, dataSet, basisTemplate, title):
        self.basisTemplate = Basis(basisTemplate)
        self.dataSet = dataSet
        self.preceeding = self.defaultPreceeding #initizialize method var to static var value
        self.pointsToExtrapolate = None
        self.title = title

    def setPointsToExtrapolate(self, *xargs):
        points = xargs

        #in case we have been given basis set names
        if not points:
            points = self.dataSet.getData(wavefunction=self.type)#.keepData(extrapolated=False)
            if self.title:
                points = points.getData(title=self.title)
            basisPoints = []
            for basis in points.getAttributeSet('basis'): #this returns a list
                basisPoints.append( Basis(basis) )
            basisPoints.sort()
            startIndex = -self.numberToExtrapolate
            self.pointsToExtrapolate = basisPoints[startIndex:]
        else:
            self.pointsToExtrapolate = points

    def getCorrection(self, basis):
        point1 = self.getDataPoint(basis=basis, wavefunction=self.type)
        if self.preceeding:
            point2 = self.getDataPoint(basis=basis, wavefunction=self.preceeding)
            newval = point1 - point2

            newwav = "d(%s)" % self.type
            newval.setAttributes(wavefunction=newwav)
        else:
            point1

    def extrapolatePreceeding(self):
        #try to extrapolate the previous data
        precExtrap = Extrapolation(self.preceeding, self.dataSet, self.basisTemplate, self.title)
        try:
            precExtrap.extrapolate()
            precData = self.dataSet.getData(wavefunction=self.preceeding)
            #if we have a title, filter by the title
            if self.title:
                precData = precData.getData(title=self.title)
            return precData
        except ComputationError, error: #we don't have the data to extrapolate the previous level of theory
            sys.stderr.write("Tried to extrapolate preceeding theory %s. %s\n" % (self.preceeding, error))
            return DataSet() #send back an empty set

    def extrapolate(self, returnData=False, force=False):
        #the new data generated by the extrapolation
        newData = DataSet()

        rawData = self.dataSet
        if self.title: #filter by title
            rawData = rawData.getData(title=self.title)

        cbsCheck = rawData.getData(basis='cbs')
        if not force and len(cbsCheck): #this is already done
            return
        
        precData = DataSet()
        #determine whether the data to be extrapolated is just the self data or a difference data 
        if self.preceeding:
            precData = self.extrapolatePreceeding()
        #build the data set for extrapolation
        extrapData = rawData.getData(wavefunction=self.extrapolationType).removeData(extrapolated=True)
        #and the data set that will contain the total energies
        fullData = rawData.getData(wavefunction=self.type).removeData(extrapolated=True)
        #make sure we have set the points to extrapolate
        if not self.pointsToExtrapolate:
            self.setPointsToExtrapolate()


        #build the data to extrapolate
        #this is done by getting all of the energy points and converting the string basis sets into numbers
        energy_points = []
        basis_points = []
        errormsg = "Cannot extrapolate. No value for %s/%s" 
        if self.title:
            errormsg += " %s" % self.title
        for basis in self.pointsToExtrapolate:
            matchbasis = self.basisTemplate.replace(basis) 
            dataPoint = extrapData.getDataPoint(basis=matchbasis)
            if not dataPoint and self.preceeding: #try to build it
                precPoint = precData.getDataPoint(basis=matchbasis)
                fullPoint = fullData.getDataPoint(basis=matchbasis)
                if fullPoint and precPoint:
                    dataPoint = dataPoint - precPoint
                else:
                    raise DataError(errormsg % (self.type, matchbasis))
            elif not dataPoint:
                raise DataError(errormsg % (self.type, matchbasis))
            energy_points.append(float(dataPoint))
            basis_points.append(getBasisNumber(basis))

        #when we build data points, we want to keep track of the type of extrapolation that we did
        extrapolationType = "-".join(map(lambda x: "%d" % x, basis_points))

        #try to do the extrapolation
        #if it fails, throw an exception since we can no longer proceed
        try:
            extrapParams = self.getExtrapolationParameters(basis_points, energy_points)
            if extrapParams[0] > energy_points[-1]:
                msg = "Energy went up on extrapolation for basis sets %s and energy points %s." % (basis_points, energy_points)
                if self.title:
                    msg += " %s didn't work." % self.title
                sys.stderr.write("%s\n" % msg)
        except ValueError:
            basisString = ",".join(map(repr, basis_points))
            energyString = ",".join(map(repr, energy_points))
            raise ComputationError("Error extrapolating %s with basis sets %s and energy points %s" % (self.type, basisString, energyString))

        #build a "template" for the extrapolated data points
        for data in extrapData:
            template = data
            break

        basisList = []
        for i in range(2, MAX_BASIS): 
            basisList.append(i)
        basisList.append('cbs')

        for basis in basisList:
            newBasis = self.basisTemplate.replace(basis)
            match = self.dataSet.findMatch(basis=newBasis, wavefunction=self.type)
            if match and isInteger(basis) and basis <= getBasisNumber(self.pointsToExtrapolate[-1]): #explicitly computed value
                match.setAttributes(extrapolated=False)
                continue
            else:
                #build the extrapolated values for the extrapolation type (i.e. dMP2 or dCCSD)
                try:
                    energy =  self.getExtrapolatedValue(basis, extrapParams)
                except ValueError:
                    paramsString = ",".join( map(repr, extrapParam) )
                    msgstring = "Error computing extrapolated value for %s/%s with extrapolation paramters %s and preceeding value %s"
                    errormsg = msgstring % (self.type, newBasis, paramsString, repr(precValue))
                    raise ExtrapolationError(errormsg)
                extrapPoint = template.copy()
                #build a label for the extrapolated value, be it an increment or just the value
                type = self.type
                extrapPoint.setAttributes(basis=newBasis,extrapolated=True,wavefunction=self.extrapolationType,
                                          extrapolationType=extrapolationType)
                extrapPoint.setValue(energy)
                self.dataSet.addDataPoint(extrapPoint) #add the extrapolated point
                if not self.preceeding:
                    continue

                precValue = precData.getDataPoint(basis=newBasis, wavefunction=self.preceeding)
                if not precValue and self.preceeding: #we are supposed to have a value and don't
                    sys.stderr.write("Cannot find value for %s in extrapolating %s for basis %s\n" % (self.preceeding, self.type, newBasis))
                elif precValue:
                    #build the new point and set its attributes appropriately
                    fullPoint = extrapPoint + precValue
                    fullPoint.setAttributes(basis=newBasis, wavefunction=self.type,extrapolated=True,
                                            extrapolationType=extrapolationType)
                    self.dataSet.addDataPoint(fullPoint)

class GroupExtrapolation(Identity):

    def __init__(self, type, dataSet, basisTemplate, titles):
        self.titles = titles
        self.basisTemplate = basisTemplate
        self.dataSet = dataSet
        self.type = type
        self.extrapolations = []
        for title in titles:
            self.extrapolations.append(Extrapolation(type, dataSet, basisTemplate, title))

    def extrapolate(self, force=False):
        for extrap in self.extrapolations:
            try:
                extrap.extrapolate(force=force)
            except DataError, error:
                sys.stderr.write("%s\n" % error)

    def setPointsToExtrapolate(self, *points):
        for extrap in self.extrapolations:
            extrap.setPointsToExtrapolate(*points)

class Extrapolation(object):

    def __new__(cls, type, dataSet, basisTemplate, title=None):
        import chem.focal
        typedict = {
            'scf' : chem.focal.SCFExtrapolation,
            'mp2' : chem.focal.MP2Extrapolation,
            'ccsd' : chem.focal.CCSDExtrapolation,
            'ccsd(t)' : chem.focal.CCSDTExtrapolation,
            'ccsdt' : chem.focal.CCSDTExtrapolation,
            'ccsdt(q)' : chem.focal.CCSDT_QExtrapolation,
        }
        if hasattr(title, '__iter__'): #we are doing an extrapolation of many things
            return GroupExtrapolation(type, dataSet, basisTemplate, title)
        else:
            clsType = typedict[type.lower()]
            obj = clsType(dataSet, basisTemplate, title)
            return obj
    

class SCFExtrapolation(ExtrapolationObject):
    
    type = "scf"
    numberToExtrapolate = 3
    defaultPreceeding = None
    extrapolationType = 'scf'

    def getExtrapolatedValue(self, basis, params):
        if len(params) == 3:
            return self.threeValue(basis, params)
        elif len(params) == 2:
            return self.twoValue(basis, params)

    def threeValue(self, basis, params):
        import math
        Escf, a, b = params
        if isinstance(basis, str) and basis.lower() == "cbs":
            return Escf
        else:
            return Escf + a * math.exp(-b * basis)  

    def twoValue(self, basis, params):
        import math
        Escf, a = params
        if isinstance(basis, str) and basis.lower() == "cbs":
            return Escf
        else:
            return Escf + a * (basis + 1) * math.exp(-9 * math.sqrt(basis))  

    def getExtrapolationParameters(self, basisSets, energies):
        import extramath
        if len(basisSets) == 3:
            return extramath.extrapolateSCF(basisSets, energies)
        elif len(basisSets) == 2:
            return extramath.extrapolate2PointSCF(basisSets, energies)
        else:
            sys.stderr.write("%s\n" % basisSets)
            raise ComputationError("Insufficient number of points given to scf extrapolation")
            

class MP2Extrapolation(ExtrapolationObject):
    
    type = "mp2"
    numberToExtrapolate = 2
    defaultPreceeding = "scf"
    extrapolationType = 'mp2 correlation'

    def getExtrapolationParameters(self, basisSets, energies):
        import extramath
        return extramath.linearRegression(basisSets, energies, ["1", "x^-3"])

    def getExtrapolatedValue(self, basis, params):
        emp2, a = params
        if isinstance(basis, str) and basis.lower() == "cbs":
            return emp2
        else:
            return emp2 + a/basis**3
        

class CCExtrapolation(ExtrapolationObject):

    type = "cc"
    numberToExtrapolate = 1
    defaultPreceeding = "?"

    def getExtrapolationParameters(self, basisSets, energies):
        #all we are after is an additive correction
        corrections = {}
        for i in range(len(basisSets)):
            corrections[basisSets[i]] = energies[i]
        return corrections, energies[-1] #the last correction

    def getExtrapolatedValue(self, basis, params):
        correctList, finalCorrection = params
        correction = 0
        if correctList.has_key(basis):
            correction = correctList[basis]
        else:
            correction = finalCorrection
        return correction

class CCSDExtrapolation(CCExtrapolation):
    type = 'ccsd'
    defaultPreceeding = 'mp2'
    extrapolationType = 'ccsd increment'

class CCSD_TExtrapolation(CCExtrapolation):
    type = 'ccsd(t)'
    extrapolationType = 'ccsd(t) increment'
    defaultPreceeding = 'ccsd'

class CCSDTExtrapolation(CCExtrapolation):
    type = 'ccsdt'
    extrapolationType = 'ccsdt increment'
    defaultPreceeding = 'ccsd(t)'

class CCSDT_QExtrapolation(CCExtrapolation):
    type = 'ccsdt(q)'
    extrapolationType = 'ccsdt(q) increment'
    defaultPreceeding = 'ccsdt'

class FocalPoint(DataSetAndPoint):

    PRECEEDING_THEORIES = {
        "ccsd" : "mp2",
        "ccsd(t)" : "ccsd",
        "ccsdt" : "ccsd(t)",
        "ccsdt(q)" : "ccsdt",
        "ccsdtq" : "ccsdt(q)"
    }

    ENERGY_LIST = [ "scf", "mp2", "ccsd", "ccsd(t)", "ccsdt", "ccsdt(q)", "ccsdtq" ]
    BASIS_LIST = [ "dz", "tz", "qz", "5z", "6z", "cbs" ]
    FORMATS = {
        'latex' : LATEX_FORMAT,
        'default' : DEFAULT_FORMAT,
    }

    basisTemplate = None

    ## Constructor
    # @param mol A molecule object
    # @param energy_groups A dictionary of energy groups to be used in the focal point
    def __init__(self, mol, dataSet=[], dataPoint=0, **kwargs):
        self.molecule = mol
        self.energy_groups = {}
        self.extrapolation = None
        #initialize with an empty 
        DataSet.__init__(self, dataSet)
        #initialize the data point as 0
        DataPoint.__init__(self, dataPoint, units="hartree", attributes=kwargs)
        self.energy = 0

    def __mul__(self, number):
        newData = DataSet.__mul__(self, other)
        newFocal = FocalPoint(self.molecule.copy(), newData)
        newFocal.setExtrapolation(self.extrapolation)
        DataPoint.setAttributes(newFocal, self.getAttributes())
        newFocal.energy = self.energy * number
        return newFocal

    def __add__(self, other):
        newDataSet = DataSet.__add__(self, other)
        newDataPoint = DataPoint.__add__(self, other)
        newFocal = FocalPoint(self.molecule.copy(), newDataSet, newDataPoint)
        newFocal.setExtrapolation(self.extrapolation)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = self.energy + other.energy
        return newFocal

    def __radd__(self, other):
        newData = DataSet.__add__(self, other)
        newFocal = FocalPoint(self.molecule.copy(), newData)
        newFocal.setExtrapolation(self.extrapolation)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = other.energy + self.energy
        return newFocal

    def __sub__(self, other):
        newData = DataSet.__sub__(self, other)
        newFocal = FocalPoint(self.molecule.copy(), newData)
        newFocal.setExtrapolation(self.extrapolation)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = self.energy - other.energy
        return newFocal

    def __rsub__(self, other):
        newData = DataSet.__rsub__(self, other)
        newFocal = FocalPoint(self.molecule.copy(), newData)
        newFocal.setExtrapolation(self.extrapolation)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = other.energy - self.energy
        return newFocal

    def compute(self, extrapolation=None): 
        preceedingGroup = None
        preceedingType = None
        for e_type in self.ENERGY_LIST:
            if self.extrapolation and not self.extrapolation.includeEnergy(e_type):
                continue

            eGroup = Extrapolation(type=e_type, dataSet=self, basisTemplate=self.basisTemplate)
            if self.extrapolation:
                eGroup.setPointsToExtrapolate(self.extrapolation[e_type])

            #now extrapolate
            try:
                eGroup.extrapolate()
            except DataError, error:
                print error
                print self.molecule
                raise ComputeError

            self.energy = self.getDataPoint(wavefunction=e_type, basis='cbs')
            self.energy.setUnits('hartree')

        #set value formats for any tables you may want to do later
        for format in self.FORMATS:
            self.setValueFormat(self.FORMATS[format], format)

        #import filemaker
        #print filemaker.makeTable(self.getDataTable('basis', 'wavefunction'), 'default')

        self.setAttribute('computed', True)

    def setBasisTemplate(template):
        FocalPoint.basisTemplate = template

    def getEnergy(self):
        computed = self.getAttribute('computed')
        if not computed:
            self.compute()
        return self.energy

    def getMolecule(self):
        return self.molecule

    def setExtrapolation(self, extrapolation):
        self.extrapolation = extrapolation

    setBasisTemplate = staticmethod(setBasisTemplate)
        

class MolecularEnergy(DataSetAndPoint):

    def __init__(self, molecule, dataSet = [], dataPoint = 0):
        self.molecule = molecule
        DataSet.__init__(self, dataSet)
        DataPoint.__init__(self, dataPoint, units="hartree")
        self.computed = False

        #and create a blank focal point instance if we don't have one
        fp = self.getDataPoint(energyType=FocalPoint)
        if not fp:
            fp = FocalPoint(molecule)
            self.addDataPoint(fp, energyType=FocalPoint)

        self.energy = 0

    def __str__(self):
        str_arr = [DataSet.__str__(self), DataPoint.__str__(self)]
        return "\n".join(str_arr)

    def __mul__(self, number):
        newData = DataSet.__mul__(self, other)
        newFocal = MolecularEnergy(self.molecule.copy(), newData)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = other.energy - self.energy
        return newFocal

    def __add__(self, other):
        newData = DataSet.__add__(self, other)
        newFocal = MolecularEnergy(self.molecule.copy(), newData)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = other.energy - self.energy
        return newFocal

    def __radd__(self, other):
        newData = DataSet.__add__(self, other)
        newFocal = MolecularEnergy(self.molecule.copy(), newData)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = other.energy - self.energy
        return newFocal

    def __sub__(self, other):
        newData = DataSet.__sub__(self, other)
        newFocal = MolecularEnergy(self.molecule.copy(), newData)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = other.energy - self.energy
        return newFocal

    def __rsub__(self, other):
        newData = DataSet.__rsub__(self, other)
        newFocal = MolecularEnergy(self.molecule.copy(), newData)
        DataPoint.setAttributes(newFocal, self.getCommonAttributes(other))
        newFocal.energy = other.energy - self.energy
        return newFocal

    def getMolecule(self):
        return self.molecule

    def compute(self):
        for point in self:
            if hasattr(point, "compute"):
                point.compute()

        self.energy = self[0]
        for point in self[1:]:
            self.energy = self.energy + point
        self.setAttribute('computed', True)

    def getEnergy(self):
        computed = self.getAttribute('computed')
        if not computed:
            self.compute()

        return self.energy

    def addDataPoint(self, task, **kwargs):
        if isinstance(task, EnergyCorrection):
            kwargs["energyType"] = task.__class__
            DataSet.addDataPoint(self, dataPoint, energyType=task.__class__)
        if isinstance(task, FocalPoint):
            DataSet.addDataPoint(self, task, attributes=kwargs, energyType=FocalPoint)
        elif isinstance(task, EnergyTask):
            basis = task.getAttribute("basis")
            if basis.lower() == "custom": #hmm.. try to get the basis from the folder
                folder = task.getFolder()
                basis.setBasisFromFolder(folder)
            energies = task.getAllEnergies()
            fp = self.getDataPoint(energyType=FocalPoint)
            for energy in energies:
                energy.setAttributes(basis=basis)
                energy.setUnits('hartree')
                fp.addDataPoint(energy, **kwargs)
        elif isinstance(task, DataPoint):
            DataSet.addDataPoint(self, task, attributes=kwargs)

    def getFocalPoint(self):
        return self.getDataPoint(energyType=FocalPoint)

    def setExtrapolation(self, extrap):
        #attempt to find the focal point
        fp = self.getDataPoint(energyType=FocalPoint)
        fp.setExtrapolation(extrap)
            
    def getProperty(self, prop):
        classType = prop
        return self.getDataPoint(energyType=classType)
        
    def getSummary(self, units="kcal"):
        strret = "Final Energy: %12.8f %s" % (self.getEnergy().getValue(units=units), units)
        return strret

class ReactionSet:

    def __init__(self, extrapolation):
        self.extrapolation = extrapolation
        self.moleculeList = {}
        self.titles = {}

    def setValueFormat(self, format, environment, **kwargs):
        for label in self.moleculeList:
            self.moleculeList[label].setValueFormat(format, environment, **kwargs)

    def addEnergy(self, task):
        mol = task.getMolecule()
        if self.extrapolation.includeTask(task):
            self.registerMolecule(mol)
            self.addValueForMolecule(mol, task)

    def registerMolecule(self, mol):
        if isinstance(mol, str):
            mol = getMolecule(mol)

        label = mol.getHash()
        title = mol.getAttribute("title").lower()
        #store the title... we want to make a connection between titles and labels
        if self.titles.has_key(label):
            if not title in self.titles[label]:
                self.titles[label].append(title)
        else:
            self.titles[label] = [title]

        if not self.moleculeList.has_key(label):
            self.moleculeList[label] = MolecularEnergy(mol)

    def addValueForMolecule(self, mol, task):
        label = mol.getHash()
        self.moleculeList[label].addDataPoint(task)

    def organizeList(self):
        for label in self.moleculeList.keys():
            for title in self.extrapolation.getTitles():
                if title in self.titles[label]:
                    self.moleculeList[label].setAttribute("title", title)
                    self.moleculeList[title] = self.moleculeList[label]
            #no matter what, delete
            del self.moleculeList[label]
            
    def compute(self):        
        #first organize the list so the titles are correct
        self.organizeList()

        for molname in self.moleculeList:
            molecule = self.moleculeList[molname]
            title = molecule.getAttribute("title")
            print "Extrapolating %s" % title
            molecule.setExtrapolation(self.extrapolation)
            molecule.compute()

        self.reactions = {}
        for reactants, products in self.extrapolation.getReactions():
            #set the matching criteria
            newCriteria = 'basis', 'wavefunction', 'energyType'
            #then we must add together products and reactants
            reactant = self.moleculeList[reactants[0]]
            reactant_names = [ reactants[0] ]
            reactant.setMatchCriteria(newCriteria)
            for name in reactants[1:]: 
                nextReactant = self.moleculeList[name]
                nextReactant.setMatchCriteria(newCriteria)
                reactant = reactant + nextReactant
                reactant_names.append(name)
            product = self.moleculeList[products[0]]
            product_names = [ products[0] ]
            product.setMatchCriteria(newCriteria)
            for name in products[1:]:
                nextProduct = self.moleculeList[name]
                nextProduct.setMatchCriteria(newCriteria)
                product = product + nextProduct
                product_names.append(name)
            #and then subtract them
            diff = product - reactant
            units = diff.getAttribute("units")
            diff.convertUnits('kcal')
            fpDiff = diff.getFocalPoint()
            diffTable = fpDiff.getDataTable('basis', 'wavefunction',columnInclude=METHODS)
            title = "%s -> %s" % ( " + ".join(reactant_names), " + ".join(product_names) )
            self.reactions[title] = diff

    def setExtrapolation(self, extrapolation):
        self.extrapolation = extrapolation

    def getSummary(self):
        str_array = []
        for title in self.reactions:
            diff = self.reactions[title]
            str_array.append(title)
            str_array.append( "%s\n" % diff.getSummary() )

        return "\n".join(str_array)

    def printFocalPointTable(self, type='default'):
        for title in self.reactions:
            print title
            diff = self.reactions[title]
            focal = diff.getFocalPoint()

            #now we want to subtract the mp2 from the scf
            incrementalData = []

            preceeding = None
            finalData = None
            eTypes = []
            for etype in FocalPoint.ENERGY_LIST:
                nextData = focal.getData(wavefunction=etype)
                if nextData and preceeding: #subtract!
                    nextData.setMatchCriteria('basis')
                    preceeding.setMatchCriteria('basis')
                    newData = nextData - preceeding
                    newData.setAttributes(wavefunction=etype)
                    preceeding = nextData
                    finalData = nextData #keep update 
                    incrementalData.extend(newData)
                    eTypes.append(etype)
                elif nextData:
                    newData = nextData
                    preceeding = nextData
                    finalData = nextData #keep update 
                    incrementalData.extend(newData)
                    eTypes.append(etype)
            eTypes.append('Final E')

            basisTemplate = self.extrapolation.getBasisTemplate()
            basisSets = map( lambda x: basisTemplate % x, range(2, MAX_BASIS) ) + ['cbs']
            #add the final energies as a column
            finalData = finalData.copy() #make a copy so we don't overwrite things
            finalData.setAttributes(wavefunction='Final E')
            incrementalData.extend(finalData)
            incrementalData = DataSet(incrementalData)
            incrementalData.convertUnits('kcal')
            incrementedFP = incrementalData.getDataTable(row=('basis', basisSets), column=('wavefunction',eTypes), sort=False)
            import filemaker
            print filemaker.makeTable(incrementedFP, type=type)

    def addEnergyFile(self, file):
        from chem.quantum import taskmake
        task = taskmake.buildTask(file)
        if task:
            self.addEnergy(task)

    def walk(self):
        self.energyPoints = []
        os.path.walk(".", projectWalk, self)
            
def projectWalk(project, dirname, filelist):
    valid_files = [elem for elem in filelist if not os.path.split(elem)[1].split(".")[-1] in ('zip', 'tar', 'pickle')]
    for filename in valid_files:
        filepath = os.path.join(dirname, filename)
        project.addEnergyFile(filepath)

class ExtrapolationSet:

    def __init__(self, extrapolation, reactions, basisTemplate=None, **kwargs):
        self.extrapolations = {}
        for wfn in extrapolation:
            self.extrapolations[wfn.lower()] = extrapolation[wfn]
        self.titles = []
    
        if not basisTemplate:   
            self.basisTemplate = Basis('CC-PV%sZ')
        else: 
            self.basisTemplate = Basis(basisTemplate)
        FocalPoint.setBasisTemplate(self.basisTemplate)

        self.specialCorrections = {}
        for key in kwargs:
            spec = kwargs[key]
            if spec:
                method, basis = spec.split("/")
                self.specialCorrections[key] = method, basis

        #build the reaction info
        self.reactions = []
        reac_array = deleteBlankLines(reactions).splitlines()
        for reac in reac_array:
            reactants, products = reac.split("->")
            clean = lambda x: x.strip().lower()
            reactants = map(clean, reactants.split("+"))
            products = map(clean, products.split("+"))
            self.reactions.append([reactants, products])

            #add any titles to the list
            for mol in reactants:
                if not mol in self.titles: self.titles.append(mol)
            for mol in products:
                if not mol in self.titles: self.titles.append(mol)
        
    def __iter__(self):
        return iter(self.extrapolations)

    def __getitem__(self, item):
        return self.extrapolations[item.lower()]

    def includeEnergy(self, e):
        return e.lower() in self.extrapolations

    def getBasisTemplate(self):
        return self.basisTemplate

    def buildAllTasks(self, computation):

        allTasks = []
        #no need to repeat ourseves for basis sets already done
        bases_already_done = []
        mrcc_bases_done = []
        theories = ["ccsdtq", "ccsdt(q)", "ccsdt", "ccsd(t)", "ccsd", "mp2", "scf"]
        from chem.quantum import taskmake
        for wfn in theories:
            if wfn in self.extrapolations:
                newComp = computation.copy()
                newComp.setAttributes(jobtype='singlepoint')
                newComp.setAttribute("wavefunction", wfn)
                if "mp2" in wfn and computation.getAttribute('reference') == "rohf":
                    #oops, better do zapt with mpqc
                    newComp.setAttribute("program", "mpqc")
                    basisList = getBasisSetsUpTo(maxBasis, basisTemplate=self.basisTemplate)
                    #zapt is not included in the hierarchy... i.e. you can't ge the zapt from the ccsd
                    for basis in basisList:
                        newComp.setAttribute("basis", basis)
                        nextTask = taskmake(newComp)
                        allTasks.append(nextTask)
                else:
                    maxBasis = self.extrapolations[wfn][-1]

                    basisList = getBasisSetsUpTo(maxBasis, basisTemplate=self.basisTemplate)
                    #go in reverse order
                    basisList.reverse()
                    for basis in basisList:
                        newComp.setAttribute("basis", basis)
                        if "ccsdt" in wfn:
                            newComp.setAttribute("program", "mrcc")
                            #don't be redundant
                            if basis in mrcc_bases_done: 
                                break
                            mrcc_bases_done.append(basis)
                        else:  
                            #don't be redundant
                            if basis in bases_already_done: 
                                break
                            bases_already_done.append(basis)
                            newComp.setAttribute("program", "molpro")
                        nextTask = taskmake(computation)
                        allTasks.append(nextTask)

        for correction in self.specialCorrections:
            method, basis = self.specialCorrections
            nextTask = taskmake(computation, jobtype=correction)
            nextTask.setAttribute('wavefunction', method)
            nextTask.setATtribute('basis', basis)
            allTasks.append(nextTask)

        return allTasks

    def getReactions(self):
        return self.reactions

    def getTitles(self):
        return self.titles
        
    def includeTask(self, task):
        jobtype = task.getAttribute("jobtype")
        if jobtype == "singlepoint": 
            wfn = task.getAttribute("wavefunction")
            if wfn in self.extrapolations: 
                return True
            else:
                return False
        else:
            if jobtype in self.specialCorrections:
                return True
            else:
                return False

    def getSpecialCorrections(self):
        return self.specialCorrections

